   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "arm_mat_inverse_f32.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.arm_mat_inverse_f32,"ax",%progbits
  20              	 .align 2
  21              	 .global arm_mat_inverse_f32
  22              	 .thumb
  23              	 .thumb_func
  25              	arm_mat_inverse_f32:
  26              	.LFB135:
  27              	 .file 1 "../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c"
   1:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /* ----------------------------------------------------------------------
   2:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Project:      CMSIS DSP Library
   3:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Title:        arm_mat_inverse_f32.c
   4:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Description:  Floating-point matrix inverse
   5:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
   6:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * $Date:        27. January 2017
   7:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * $Revision:    V.1.5.1
   8:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
   9:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Target Processor: Cortex-M cores
  10:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * -------------------------------------------------------------------- */
  11:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /*
  12:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Copyright (C) 2010-2017 ARM Limited or its affiliates. All rights reserved.
  13:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  14:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * SPDX-License-Identifier: Apache-2.0
  15:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  16:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  17:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * not use this file except in compliance with the License.
  18:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * You may obtain a copy of the License at
  19:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  20:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * www.apache.org/licenses/LICENSE-2.0
  21:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  22:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Unless required by applicable law or agreed to in writing, software
  23:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  24:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  25:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * See the License for the specific language governing permissions and
  26:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * limitations under the License.
  27:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  28:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  29:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #include "CMSIS_DSP/cmsis_dsp.h"
  30:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  31:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /**
  32:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @ingroup groupMatrix
  33:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  34:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  35:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /**
  36:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @defgroup MatrixInv Matrix Inverse
  37:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  38:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Computes the inverse of a matrix.
  39:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  40:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * The inverse is defined only if the input matrix is square and non-singular (the determinant
  41:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * is non-zero). The function checks that the input and output matrices are square and of the
  42:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * same size.
  43:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  44:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Matrix inversion is numerically sensitive and the CMSIS DSP library only supports matrix
  45:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * inversion of floating-point matrices.
  46:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  47:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * \par Algorithm
  48:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * The Gauss-Jordan method is used to find the inverse.
  49:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * The algorithm performs a sequence of elementary row-operations until it
  50:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * reduces the input matrix to an identity matrix. Applying the same sequence
  51:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * of elementary row-operations to an identity matrix yields the inverse matrix.
  52:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * If the input matrix is singular, then the algorithm terminates and returns error status
  53:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * <code>ARM_MATH_SINGULAR</code>.
  54:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * \image html MatrixInverse.gif "Matrix Inverse of a 3 x 3 matrix using Gauss-Jordan Method"
  55:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  56:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  57:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /**
  58:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @addtogroup MatrixInv
  59:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @{
  60:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  61:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  62:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /**
  63:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @brief Floating-point matrix inverse.
  64:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @param[in]       *pSrc points to input matrix structure
  65:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @param[out]      *pDst points to output matrix structure
  66:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @return     		The function returns
  67:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * <code>ARM_MATH_SIZE_MISMATCH</code> if the input matrix is not square or if the size
  68:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * of the output matrix does not match the size of the input matrix.
  69:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * If the input matrix is found to be singular (non-invertible), then the function returns
  70:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * <code>ARM_MATH_SINGULAR</code>.  Otherwise, the function returns <code>ARM_MATH_SUCCESS</code>.
  71:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  72:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  73:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** arm_status arm_mat_inverse_f32(
  74:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   const arm_matrix_instance_f32 * pSrc,
  75:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   arm_matrix_instance_f32 * pDst)
  76:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** {
  28              	 .loc 1 76 0
  29              	 .cfi_startproc
  30              	 
  31              	 
  32              	 
  33 0000 80B4     	 push {r7}
  34              	.LCFI0:
  35              	 .cfi_def_cfa_offset 4
  36              	 .cfi_offset 7,-4
  37 0002 9BB0     	 sub sp,sp,#108
  38              	.LCFI1:
  39              	 .cfi_def_cfa_offset 112
  40 0004 00AF     	 add r7,sp,#0
  41              	.LCFI2:
  42              	 .cfi_def_cfa_register 7
  43 0006 7860     	 str r0,[r7,#4]
  44 0008 3960     	 str r1,[r7]
  77:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
  45              	 .loc 1 77 0
  46 000a 7B68     	 ldr r3,[r7,#4]
  47 000c 5B68     	 ldr r3,[r3,#4]
  48 000e 7B66     	 str r3,[r7,#100]
  78:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
  49              	 .loc 1 78 0
  50 0010 3B68     	 ldr r3,[r7]
  51 0012 5B68     	 ldr r3,[r3,#4]
  52 0014 3B62     	 str r3,[r7,#32]
  79:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pInT1, *pInT2;                      /* Temporary input data matrix pointer */
  80:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pOutT1, *pOutT2;                    /* Temporary output data matrix pointer */
  81:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pPivotRowIn, *pPRT_in, *pPivotRowDst, *pPRT_pDst;  /* Temporary input and output data 
  82:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
  53              	 .loc 1 82 0
  54 0016 7B68     	 ldr r3,[r7,#4]
  55 0018 1B88     	 ldrh r3,[r3]
  56 001a FB61     	 str r3,[r7,#28]
  83:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
  57              	 .loc 1 83 0
  58 001c 7B68     	 ldr r3,[r7,#4]
  59 001e 5B88     	 ldrh r3,[r3,#2]
  60 0020 BB61     	 str r3,[r7,#24]
  84:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  85:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #if defined (ARM_MATH_DSP)
  86:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t maxC;                                /* maximum value in the column */
  87:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  88:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Run the below code for Cortex-M4 and Cortex-M3 */
  89:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  90:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t Xchg, in = 0.0f, in1;                /* Temporary input values  */
  61              	 .loc 1 90 0
  62 0022 4FF00003 	 mov r3,#0
  63 0026 7B64     	 str r3,[r7,#68]
  91:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t i, rowCnt, flag = 0u, j, loopCnt, k, l;      /* loop counters */
  64              	 .loc 1 91 0
  65 0028 0023     	 movs r3,#0
  66 002a BB63     	 str r3,[r7,#56]
  92:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   arm_status status;                             /* status of matrix inverse */
  93:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  94:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #ifdef ARM_MATH_MATRIX_CHECK
  95:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  96:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  97:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Check for matrix mismatch condition */
  98:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   if ((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
  67              	 .loc 1 98 0
  68 002c 7B68     	 ldr r3,[r7,#4]
  69 002e 1A88     	 ldrh r2,[r3]
  70 0030 7B68     	 ldr r3,[r7,#4]
  71 0032 5B88     	 ldrh r3,[r3,#2]
  72 0034 9A42     	 cmp r2,r3
  73 0036 0BD1     	 bne .L2
  74              	 .loc 1 98 0 is_stmt 0 discriminator 1
  75 0038 3B68     	 ldr r3,[r7]
  76 003a 1A88     	 ldrh r2,[r3]
  77 003c 3B68     	 ldr r3,[r7]
  78 003e 5B88     	 ldrh r3,[r3,#2]
  79 0040 9A42     	 cmp r2,r3
  80 0042 05D1     	 bne .L2
  99:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****      || (pSrc->numRows != pDst->numRows))
  81              	 .loc 1 99 0 is_stmt 1
  82 0044 7B68     	 ldr r3,[r7,#4]
  83 0046 1A88     	 ldrh r2,[r3]
  84 0048 3B68     	 ldr r3,[r7]
  85 004a 1B88     	 ldrh r3,[r3]
  86 004c 9A42     	 cmp r2,r3
  87 004e 03D0     	 beq .L3
  88              	.L2:
 100:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   {
 101:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Set status as ARM_MATH_SIZE_MISMATCH */
 102:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     status = ARM_MATH_SIZE_MISMATCH;
  89              	 .loc 1 102 0
  90 0050 FD23     	 movs r3,#253
  91 0052 87F82730 	 strb r3,[r7,#39]
  92 0056 16E2     	 b .L4
  93              	.L3:
 103:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   }
 104:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   else
 105:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
 106:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 107:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   {
 108:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 109:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /*---------------------------------------------------------------------------------------------
 110:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 * Matrix Inverse can be solved using elementary row operations.
 111:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 112:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	Gauss-Jordan Method:
 113:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 114:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an
 115:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *        augmented matrix as follows:
 116:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *				        _ 	      	       _         _	       _
 117:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |  a11  a12 | 1   0  |       |  X11 X12  |
 118:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |           |        |   =   |           |
 119:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |_ a21  a22 | 0   1 _|       |_ X21 X21 _|
 120:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 121:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		2. In our implementation, pDst Matrix is used as identity matrix.
 122:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 123:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		3. Begin with the first row. Let i = 1.
 124:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 125:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    4. Check to see if the pivot for column i is the greatest of the column.
 126:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   The pivot is the element of the main diagonal that is on the current row.
 127:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   For instance, if working with row i, then the pivot element is aii.
 128:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   If the pivot is not the most significant of the columns, exchange that row with a row
 129:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   below it that does contain the most significant value in column i. If the most
 130:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *         significant value of the column is zero, then an inverse to that matrix does not exist.
 131:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   The most significant value of the column is the absolute maximum.
 132:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 133:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    5. Divide every element of row i by the pivot.
 134:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 135:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    6. For every row below and  row i, replace that row with the sum of that row and
 136:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   a multiple of row i so that each new element in column i below row i is zero.
 137:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 138:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros
 139:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   for every element below and above the main diagonal.
 140:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 141:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, pSrc).
 142:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   Therefore, the matrix to the right of the bar is our solution(pDst matrix, pDst).
 143:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *------------------------------------------------------------------------------------------------
 144:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 145:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Working pointer for destination matrix */
 146:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     pOutT1 = pOut;
  94              	 .loc 1 146 0
  95 0058 3B6A     	 ldr r3,[r7,#32]
  96 005a BB65     	 str r3,[r7,#88]
 147:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 148:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of rows */
 149:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     rowCnt = numRows;
  97              	 .loc 1 149 0
  98 005c FB69     	 ldr r3,[r7,#28]
  99 005e FB63     	 str r3,[r7,#60]
 150:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 151:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Making the destination matrix as identity matrix */
 152:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     while (rowCnt > 0u)
 100              	 .loc 1 152 0
 101 0060 29E0     	 b .L5
 102              	.L10:
 153:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 154:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in lower triangle of the destination matrix */
 155:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = numRows - rowCnt;
 103              	 .loc 1 155 0
 104 0062 FA69     	 ldr r2,[r7,#28]
 105 0064 FB6B     	 ldr r3,[r7,#60]
 106 0066 D31A     	 subs r3,r2,r3
 107 0068 7B63     	 str r3,[r7,#52]
 156:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0u)
 108              	 .loc 1 156 0
 109 006a 08E0     	 b .L6
 110              	.L7:
 157:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 158:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
 111              	 .loc 1 158 0
 112 006c BB6D     	 ldr r3,[r7,#88]
 113 006e 1A1D     	 adds r2,r3,#4
 114 0070 BA65     	 str r2,[r7,#88]
 115 0072 4FF00002 	 mov r2,#0
 116 0076 1A60     	 str r2,[r3]
 159:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 117              	 .loc 1 159 0
 118 0078 7B6B     	 ldr r3,[r7,#52]
 119 007a 013B     	 subs r3,r3,#1
 120 007c 7B63     	 str r3,[r7,#52]
 121              	.L6:
 156:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0u)
 122              	 .loc 1 156 0
 123 007e 7B6B     	 ldr r3,[r7,#52]
 124 0080 002B     	 cmp r3,#0
 125 0082 F3D1     	 bne .L7
 160:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 161:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 162:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all ones in the diagonal of the destination matrix */
 163:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       *pOutT1++ = 1.0f;
 126              	 .loc 1 163 0
 127 0084 BB6D     	 ldr r3,[r7,#88]
 128 0086 1A1D     	 adds r2,r3,#4
 129 0088 BA65     	 str r2,[r7,#88]
 130 008a 4FF07E52 	 mov r2,#1065353216
 131 008e 1A60     	 str r2,[r3]
 164:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 165:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in upper triangle of the destination matrix */
 166:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = rowCnt - 1u;
 132              	 .loc 1 166 0
 133 0090 FB6B     	 ldr r3,[r7,#60]
 134 0092 013B     	 subs r3,r3,#1
 135 0094 7B63     	 str r3,[r7,#52]
 167:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0u)
 136              	 .loc 1 167 0
 137 0096 08E0     	 b .L8
 138              	.L9:
 168:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 169:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
 139              	 .loc 1 169 0
 140 0098 BB6D     	 ldr r3,[r7,#88]
 141 009a 1A1D     	 adds r2,r3,#4
 142 009c BA65     	 str r2,[r7,#88]
 143 009e 4FF00002 	 mov r2,#0
 144 00a2 1A60     	 str r2,[r3]
 170:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 145              	 .loc 1 170 0
 146 00a4 7B6B     	 ldr r3,[r7,#52]
 147 00a6 013B     	 subs r3,r3,#1
 148 00a8 7B63     	 str r3,[r7,#52]
 149              	.L8:
 167:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0u)
 150              	 .loc 1 167 0
 151 00aa 7B6B     	 ldr r3,[r7,#52]
 152 00ac 002B     	 cmp r3,#0
 153 00ae F3D1     	 bne .L9
 171:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 172:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 173:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement the loop counter */
 174:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       rowCnt--;
 154              	 .loc 1 174 0
 155 00b0 FB6B     	 ldr r3,[r7,#60]
 156 00b2 013B     	 subs r3,r3,#1
 157 00b4 FB63     	 str r3,[r7,#60]
 158              	.L5:
 152:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 159              	 .loc 1 152 0
 160 00b6 FB6B     	 ldr r3,[r7,#60]
 161 00b8 002B     	 cmp r3,#0
 162 00ba D2D1     	 bne .L10
 175:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 176:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 177:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of columns of the input matrix.
 178:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        All the elements in each column are processed by the row operations */
 179:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     loopCnt = numCols;
 163              	 .loc 1 179 0
 164 00bc BB69     	 ldr r3,[r7,#24]
 165 00be 3B63     	 str r3,[r7,#48]
 180:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 181:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Index modifier to navigate through the columns */
 182:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     l = 0u;
 166              	 .loc 1 182 0
 167 00c0 0023     	 movs r3,#0
 168 00c2 BB62     	 str r3,[r7,#40]
 183:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 184:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     while (loopCnt > 0u)
 169              	 .loc 1 184 0
 170 00c4 A8E1     	 b .L11
 171              	.L52:
 185:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 186:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is zero..
 187:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * If it is zero then interchange the row with non zero row below.
 188:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * If there is no non zero element to replace in the rows below,
 189:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * then the matrix is Singular. */
 190:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 191:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the input matrix that points
 192:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
 193:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn + (l * numCols);
 172              	 .loc 1 193 0
 173 00c6 BB6A     	 ldr r3,[r7,#40]
 174 00c8 BA69     	 ldr r2,[r7,#24]
 175 00ca 02FB03F3 	 mul r3,r2,r3
 176 00ce 9B00     	 lsls r3,r3,#2
 177 00d0 7A6E     	 ldr r2,[r7,#100]
 178 00d2 1344     	 add r3,r3,r2
 179 00d4 3B66     	 str r3,[r7,#96]
 194:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 195:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the destination matrix that points
 196:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
 197:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pOut + (l * numCols);
 180              	 .loc 1 197 0
 181 00d6 BB6A     	 ldr r3,[r7,#40]
 182 00d8 BA69     	 ldr r2,[r7,#24]
 183 00da 02FB03F3 	 mul r3,r2,r3
 184 00de 9B00     	 lsls r3,r3,#2
 185 00e0 3A6A     	 ldr r2,[r7,#32]
 186 00e2 1344     	 add r3,r3,r2
 187 00e4 BB65     	 str r3,[r7,#88]
 198:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 199:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary variable to hold the pivot value */
 200:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *pInT1;
 188              	 .loc 1 200 0
 189 00e6 3B6E     	 ldr r3,[r7,#96]
 190 00e8 1B68     	 ldr r3,[r3]
 191 00ea 7B64     	 str r3,[r7,#68]
 201:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 202:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Grab the most significant value from column l */
 203:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       maxC = 0;
 192              	 .loc 1 203 0
 193 00ec 4FF00003 	 mov r3,#0
 194 00f0 BB64     	 str r3,[r7,#72]
 204:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = l; i < numRows; i++)
 195              	 .loc 1 204 0
 196 00f2 BB6A     	 ldr r3,[r7,#40]
 197 00f4 3B64     	 str r3,[r7,#64]
 198 00f6 36E0     	 b .L12
 199              	.L22:
 205:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 206:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         maxC = *pInT1 > 0 ? (*pInT1 > maxC ? *pInT1 : maxC) : (-*pInT1 > maxC ? -*pInT1 : maxC);
 200              	 .loc 1 206 0
 201 00f8 3B6E     	 ldr r3,[r7,#96]
 202 00fa D3ED007A 	 flds s15,[r3]
 203 00fe F5EEC07A 	 fcmpezs s15
 204 0102 F1EE10FA 	 fmstat
 205 0106 10DD     	 ble .L62
 206              	 .loc 1 206 0 is_stmt 0 discriminator 1
 207 0108 3B6E     	 ldr r3,[r7,#96]
 208 010a 93ED007A 	 flds s14,[r3]
 209 010e D7ED127A 	 flds s15,[r7,#72]
 210 0112 B4EEE77A 	 fcmpes s14,s15
 211 0116 F1EE10FA 	 fmstat
 212 011a 03DD     	 ble .L63
 213              	 .loc 1 206 0 discriminator 3
 214 011c 3B6E     	 ldr r3,[r7,#96]
 215 011e D3ED007A 	 flds s15,[r3]
 216 0122 16E0     	 b .L18
 217              	.L63:
 218              	 .loc 1 206 0 discriminator 4
 219 0124 D7ED127A 	 flds s15,[r7,#72]
 220 0128 13E0     	 b .L18
 221              	.L62:
 222              	 .loc 1 206 0 discriminator 2
 223 012a 3B6E     	 ldr r3,[r7,#96]
 224 012c D3ED007A 	 flds s15,[r3]
 225 0130 B1EE677A 	 fnegs s14,s15
 226 0134 D7ED127A 	 flds s15,[r7,#72]
 227 0138 B4EEE77A 	 fcmpes s14,s15
 228 013c F1EE10FA 	 fmstat
 229 0140 05DD     	 ble .L64
 230              	 .loc 1 206 0 discriminator 8
 231 0142 3B6E     	 ldr r3,[r7,#96]
 232 0144 D3ED007A 	 flds s15,[r3]
 233 0148 F1EE677A 	 fnegs s15,s15
 234 014c 01E0     	 b .L18
 235              	.L64:
 236              	 .loc 1 206 0 discriminator 9
 237 014e D7ED127A 	 flds s15,[r7,#72]
 238              	.L18:
 239              	 .loc 1 206 0 discriminator 12
 240 0152 C7ED127A 	 fsts s15,[r7,#72]
 207:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1 += numCols;
 241              	 .loc 1 207 0 is_stmt 1 discriminator 12
 242 0156 BB69     	 ldr r3,[r7,#24]
 243 0158 9B00     	 lsls r3,r3,#2
 244 015a 3A6E     	 ldr r2,[r7,#96]
 245 015c 1344     	 add r3,r3,r2
 246 015e 3B66     	 str r3,[r7,#96]
 204:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = l; i < numRows; i++)
 247              	 .loc 1 204 0 discriminator 12
 248 0160 3B6C     	 ldr r3,[r7,#64]
 249 0162 0133     	 adds r3,r3,#1
 250 0164 3B64     	 str r3,[r7,#64]
 251              	.L12:
 204:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = l; i < numRows; i++)
 252              	 .loc 1 204 0 is_stmt 0 discriminator 2
 253 0166 3A6C     	 ldr r2,[r7,#64]
 254 0168 FB69     	 ldr r3,[r7,#28]
 255 016a 9A42     	 cmp r2,r3
 256 016c C4D3     	 bcc .L22
 208:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 209:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 210:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Update the status if the matrix is singular */
 211:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if (maxC == 0.0f)
 257              	 .loc 1 211 0 is_stmt 1
 258 016e D7ED127A 	 flds s15,[r7,#72]
 259 0172 F5EE407A 	 fcmpzs s15
 260 0176 F1EE10FA 	 fmstat
 261 017a 01D1     	 bne .L23
 212:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 213:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         return ARM_MATH_SINGULAR;
 262              	 .loc 1 213 0
 263 017c FB23     	 movs r3,#251
 264 017e 84E1     	 b .L24
 265              	.L23:
 214:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 215:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 216:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Restore pInT1  */
 217:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn;
 266              	 .loc 1 217 0
 267 0180 7B6E     	 ldr r3,[r7,#100]
 268 0182 3B66     	 str r3,[r7,#96]
 218:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 219:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Destination pointer modifier */
 220:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       k = 1u;
 269              	 .loc 1 220 0
 270 0184 0123     	 movs r3,#1
 271 0186 FB62     	 str r3,[r7,#44]
 221:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 222:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is the most significant of the column */
 223:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if ( (in > 0.0f ? in : -in) != maxC)
 272              	 .loc 1 223 0
 273 0188 D7ED117A 	 flds s15,[r7,#68]
 274 018c F5EEC07A 	 fcmpezs s15
 275 0190 F1EE10FA 	 fmstat
 276 0194 02DD     	 ble .L65
 277              	 .loc 1 223 0 is_stmt 0 discriminator 1
 278 0196 D7ED117A 	 flds s15,[r7,#68]
 279 019a 03E0     	 b .L27
 280              	.L65:
 281              	 .loc 1 223 0 discriminator 2
 282 019c D7ED117A 	 flds s15,[r7,#68]
 283 01a0 F1EE677A 	 fnegs s15,s15
 284              	.L27:
 285              	 .loc 1 223 0 discriminator 4
 286 01a4 97ED127A 	 flds s14,[r7,#72]
 287 01a8 F4EE477A 	 fcmps s15,s14
 288 01ac F1EE10FA 	 fmstat
 289 01b0 69D0     	 beq .L28
 224:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 225:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Loop over the number rows present below */
 226:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         i = numRows - (l + 1u);
 290              	 .loc 1 226 0 is_stmt 1
 291 01b2 FA69     	 ldr r2,[r7,#28]
 292 01b4 BB6A     	 ldr r3,[r7,#40]
 293 01b6 D31A     	 subs r3,r2,r3
 294 01b8 013B     	 subs r3,r3,#1
 295 01ba 3B64     	 str r3,[r7,#64]
 227:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 228:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         while (i > 0u)
 296              	 .loc 1 228 0
 297 01bc 60E0     	 b .L29
 298              	.L38:
 229:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 230:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the input and destination pointers */
 231:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT2 = pInT1 + (numCols * l);
 299              	 .loc 1 231 0
 300 01be BB69     	 ldr r3,[r7,#24]
 301 01c0 BA6A     	 ldr r2,[r7,#40]
 302 01c2 02FB03F3 	 mul r3,r2,r3
 303 01c6 9B00     	 lsls r3,r3,#2
 304 01c8 3A6E     	 ldr r2,[r7,#96]
 305 01ca 1344     	 add r3,r3,r2
 306 01cc FB65     	 str r3,[r7,#92]
 232:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pOutT2 = pOutT1 + (numCols * k);
 307              	 .loc 1 232 0
 308 01ce BB69     	 ldr r3,[r7,#24]
 309 01d0 FA6A     	 ldr r2,[r7,#44]
 310 01d2 02FB03F3 	 mul r3,r2,r3
 311 01d6 9B00     	 lsls r3,r3,#2
 312 01d8 BA6D     	 ldr r2,[r7,#88]
 313 01da 1344     	 add r3,r3,r2
 314 01dc 7B65     	 str r3,[r7,#84]
 233:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 234:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Look for the most significant element to
 235:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****            * replace in the rows below */
 236:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           if ((*pInT2 > 0.0f ? *pInT2: -*pInT2) == maxC)
 315              	 .loc 1 236 0
 316 01de FB6D     	 ldr r3,[r7,#92]
 317 01e0 D3ED007A 	 flds s15,[r3]
 318 01e4 F5EEC07A 	 fcmpezs s15
 319 01e8 F1EE10FA 	 fmstat
 320 01ec 03DD     	 ble .L66
 321              	 .loc 1 236 0 is_stmt 0 discriminator 1
 322 01ee FB6D     	 ldr r3,[r7,#92]
 323 01f0 D3ED007A 	 flds s15,[r3]
 324 01f4 04E0     	 b .L32
 325              	.L66:
 326              	 .loc 1 236 0 discriminator 2
 327 01f6 FB6D     	 ldr r3,[r7,#92]
 328 01f8 D3ED007A 	 flds s15,[r3]
 329 01fc F1EE677A 	 fnegs s15,s15
 330              	.L32:
 331              	 .loc 1 236 0 discriminator 4
 332 0200 97ED127A 	 flds s14,[r7,#72]
 333 0204 F4EE477A 	 fcmps s15,s14
 334 0208 F1EE10FA 	 fmstat
 335 020c 32D1     	 bne .L33
 237:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 238:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Loop over number of columns
 239:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              * to the right of the pilot element */
 240:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             j = numCols - l;
 336              	 .loc 1 240 0 is_stmt 1
 337 020e BA69     	 ldr r2,[r7,#24]
 338 0210 BB6A     	 ldr r3,[r7,#40]
 339 0212 D31A     	 subs r3,r2,r3
 340 0214 7B63     	 str r3,[r7,#52]
 241:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 242:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             while (j > 0u)
 341              	 .loc 1 242 0
 342 0216 10E0     	 b .L34
 343              	.L35:
 243:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 244:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Exchange the row elements of the input matrix */
 245:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pInT2;
 344              	 .loc 1 245 0
 345 0218 FB6D     	 ldr r3,[r7,#92]
 346 021a 1B68     	 ldr r3,[r3]
 347 021c 7B61     	 str r3,[r7,#20]
 246:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT2++ = *pInT1;
 348              	 .loc 1 246 0
 349 021e FB6D     	 ldr r3,[r7,#92]
 350 0220 1A1D     	 adds r2,r3,#4
 351 0222 FA65     	 str r2,[r7,#92]
 352 0224 3A6E     	 ldr r2,[r7,#96]
 353 0226 1268     	 ldr r2,[r2]
 354 0228 1A60     	 str r2,[r3]
 247:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT1++ = Xchg;
 355              	 .loc 1 247 0
 356 022a 3B6E     	 ldr r3,[r7,#96]
 357 022c 1A1D     	 adds r2,r3,#4
 358 022e 3A66     	 str r2,[r7,#96]
 359 0230 7A69     	 ldr r2,[r7,#20]
 360 0232 1A60     	 str r2,[r3]
 248:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 249:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Decrement the loop counter */
 250:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               j--;
 361              	 .loc 1 250 0
 362 0234 7B6B     	 ldr r3,[r7,#52]
 363 0236 013B     	 subs r3,r3,#1
 364 0238 7B63     	 str r3,[r7,#52]
 365              	.L34:
 242:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 366              	 .loc 1 242 0
 367 023a 7B6B     	 ldr r3,[r7,#52]
 368 023c 002B     	 cmp r3,#0
 369 023e EBD1     	 bne .L35
 251:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 252:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 253:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Loop over number of columns of the destination matrix */
 254:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             j = numCols;
 370              	 .loc 1 254 0
 371 0240 BB69     	 ldr r3,[r7,#24]
 372 0242 7B63     	 str r3,[r7,#52]
 255:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 256:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             while (j > 0u)
 373              	 .loc 1 256 0
 374 0244 10E0     	 b .L36
 375              	.L37:
 257:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 258:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Exchange the row elements of the destination matrix */
 259:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pOutT2;
 376              	 .loc 1 259 0
 377 0246 7B6D     	 ldr r3,[r7,#84]
 378 0248 1B68     	 ldr r3,[r3]
 379 024a 7B61     	 str r3,[r7,#20]
 260:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT2++ = *pOutT1;
 380              	 .loc 1 260 0
 381 024c 7B6D     	 ldr r3,[r7,#84]
 382 024e 1A1D     	 adds r2,r3,#4
 383 0250 7A65     	 str r2,[r7,#84]
 384 0252 BA6D     	 ldr r2,[r7,#88]
 385 0254 1268     	 ldr r2,[r2]
 386 0256 1A60     	 str r2,[r3]
 261:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT1++ = Xchg;
 387              	 .loc 1 261 0
 388 0258 BB6D     	 ldr r3,[r7,#88]
 389 025a 1A1D     	 adds r2,r3,#4
 390 025c BA65     	 str r2,[r7,#88]
 391 025e 7A69     	 ldr r2,[r7,#20]
 392 0260 1A60     	 str r2,[r3]
 262:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 263:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Decrement the loop counter */
 264:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               j--;
 393              	 .loc 1 264 0
 394 0262 7B6B     	 ldr r3,[r7,#52]
 395 0264 013B     	 subs r3,r3,#1
 396 0266 7B63     	 str r3,[r7,#52]
 397              	.L36:
 256:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 398              	 .loc 1 256 0
 399 0268 7B6B     	 ldr r3,[r7,#52]
 400 026a 002B     	 cmp r3,#0
 401 026c EBD1     	 bne .L37
 265:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 266:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 267:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Flag to indicate whether exchange is done or not */
 268:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             flag = 1u;
 402              	 .loc 1 268 0
 403 026e 0123     	 movs r3,#1
 404 0270 BB63     	 str r3,[r7,#56]
 269:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 270:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Break after exchange is done */
 271:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             break;
 405              	 .loc 1 271 0
 406 0272 08E0     	 b .L28
 407              	.L33:
 272:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 273:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 274:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the destination pointer modifier */
 275:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           k++;
 408              	 .loc 1 275 0
 409 0274 FB6A     	 ldr r3,[r7,#44]
 410 0276 0133     	 adds r3,r3,#1
 411 0278 FB62     	 str r3,[r7,#44]
 276:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 277:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Decrement the loop counter */
 278:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           i--;
 412              	 .loc 1 278 0
 413 027a 3B6C     	 ldr r3,[r7,#64]
 414 027c 013B     	 subs r3,r3,#1
 415 027e 3B64     	 str r3,[r7,#64]
 416              	.L29:
 228:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 417              	 .loc 1 228 0
 418 0280 3B6C     	 ldr r3,[r7,#64]
 419 0282 002B     	 cmp r3,#0
 420 0284 9BD1     	 bne .L38
 421              	.L28:
 279:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 280:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 281:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 282:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Update the status if the matrix is singular */
 283:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if ((flag != 1u) && (in == 0.0f))
 422              	 .loc 1 283 0
 423 0286 BB6B     	 ldr r3,[r7,#56]
 424 0288 012B     	 cmp r3,#1
 425 028a 08D0     	 beq .L39
 426              	 .loc 1 283 0 is_stmt 0 discriminator 1
 427 028c D7ED117A 	 flds s15,[r7,#68]
 428 0290 F5EE407A 	 fcmpzs s15
 429 0294 F1EE10FA 	 fmstat
 430 0298 01D1     	 bne .L39
 284:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 285:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         return ARM_MATH_SINGULAR;
 431              	 .loc 1 285 0 is_stmt 1
 432 029a FB23     	 movs r3,#251
 433 029c F5E0     	 b .L24
 434              	.L39:
 286:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 287:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 288:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Points to the pivot row of input and destination matrices */
 289:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowIn = pIn + (l * numCols);
 435              	 .loc 1 289 0
 436 029e BB6A     	 ldr r3,[r7,#40]
 437 02a0 BA69     	 ldr r2,[r7,#24]
 438 02a2 02FB03F3 	 mul r3,r2,r3
 439 02a6 9B00     	 lsls r3,r3,#2
 440 02a8 7A6E     	 ldr r2,[r7,#100]
 441 02aa 1344     	 add r3,r3,r2
 442 02ac 3B61     	 str r3,[r7,#16]
 290:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowDst = pOut + (l * numCols);
 443              	 .loc 1 290 0
 444 02ae BB6A     	 ldr r3,[r7,#40]
 445 02b0 BA69     	 ldr r2,[r7,#24]
 446 02b2 02FB03F3 	 mul r3,r2,r3
 447 02b6 9B00     	 lsls r3,r3,#2
 448 02b8 3A6A     	 ldr r2,[r7,#32]
 449 02ba 1344     	 add r3,r3,r2
 450 02bc FB60     	 str r3,[r7,#12]
 291:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 292:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers to the pivot row pointers */
 293:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pPivotRowIn;
 451              	 .loc 1 293 0
 452 02be 3B69     	 ldr r3,[r7,#16]
 453 02c0 3B66     	 str r3,[r7,#96]
 294:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT2 = pPivotRowDst;
 454              	 .loc 1 294 0
 455 02c2 FB68     	 ldr r3,[r7,#12]
 456 02c4 FB65     	 str r3,[r7,#92]
 295:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 296:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Pivot element of the row */
 297:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *pPivotRowIn;
 457              	 .loc 1 297 0
 458 02c6 3B69     	 ldr r3,[r7,#16]
 459 02c8 1B68     	 ldr r3,[r3]
 460 02ca 7B64     	 str r3,[r7,#68]
 298:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 299:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of columns
 300:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the right of the pilot element */
 301:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = (numCols - l);
 461              	 .loc 1 301 0
 462 02cc BA69     	 ldr r2,[r7,#24]
 463 02ce BB6A     	 ldr r3,[r7,#40]
 464 02d0 D31A     	 subs r3,r2,r3
 465 02d2 7B63     	 str r3,[r7,#52]
 302:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 303:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0u)
 466              	 .loc 1 303 0
 467 02d4 10E0     	 b .L40
 468              	.L41:
 304:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 305:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the input matrix
 306:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
 307:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         in1 = *pInT1;
 469              	 .loc 1 307 0
 470 02d6 3B6E     	 ldr r3,[r7,#96]
 471 02d8 1B68     	 ldr r3,[r3]
 472 02da BB60     	 str r3,[r7,#8]
 308:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pInT1++ = in1 / in;
 473              	 .loc 1 308 0
 474 02dc 3B6E     	 ldr r3,[r7,#96]
 475 02de 1A1D     	 adds r2,r3,#4
 476 02e0 3A66     	 str r2,[r7,#96]
 477 02e2 97ED027A 	 flds s14,[r7,#8]
 478 02e6 D7ED117A 	 flds s15,[r7,#68]
 479 02ea C7EE277A 	 fdivs s15,s14,s15
 480 02ee C3ED007A 	 fsts s15,[r3]
 309:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 310:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement the loop counter */
 311:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 481              	 .loc 1 311 0
 482 02f2 7B6B     	 ldr r3,[r7,#52]
 483 02f4 013B     	 subs r3,r3,#1
 484 02f6 7B63     	 str r3,[r7,#52]
 485              	.L40:
 303:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 486              	 .loc 1 303 0
 487 02f8 7B6B     	 ldr r3,[r7,#52]
 488 02fa 002B     	 cmp r3,#0
 489 02fc EBD1     	 bne .L41
 312:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 313:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 314:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of columns of the destination matrix */
 315:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = numCols;
 490              	 .loc 1 315 0
 491 02fe BB69     	 ldr r3,[r7,#24]
 492 0300 7B63     	 str r3,[r7,#52]
 316:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 317:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0u)
 493              	 .loc 1 317 0
 494 0302 10E0     	 b .L42
 495              	.L43:
 318:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 319:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the destination matrix
 320:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
 321:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         in1 = *pInT2;
 496              	 .loc 1 321 0
 497 0304 FB6D     	 ldr r3,[r7,#92]
 498 0306 1B68     	 ldr r3,[r3]
 499 0308 BB60     	 str r3,[r7,#8]
 322:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pInT2++ = in1 / in;
 500              	 .loc 1 322 0
 501 030a FB6D     	 ldr r3,[r7,#92]
 502 030c 1A1D     	 adds r2,r3,#4
 503 030e FA65     	 str r2,[r7,#92]
 504 0310 97ED027A 	 flds s14,[r7,#8]
 505 0314 D7ED117A 	 flds s15,[r7,#68]
 506 0318 C7EE277A 	 fdivs s15,s14,s15
 507 031c C3ED007A 	 fsts s15,[r3]
 323:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 324:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement the loop counter */
 325:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 508              	 .loc 1 325 0
 509 0320 7B6B     	 ldr r3,[r7,#52]
 510 0322 013B     	 subs r3,r3,#1
 511 0324 7B63     	 str r3,[r7,#52]
 512              	.L42:
 317:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 513              	 .loc 1 317 0
 514 0326 7B6B     	 ldr r3,[r7,#52]
 515 0328 002B     	 cmp r3,#0
 516 032a EBD1     	 bne .L43
 326:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 327:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 328:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Replace the rows with the sum of that row and a multiple of row i
 329:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * so that each new element in column i above row i is zero.*/
 330:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 331:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers for input and destination matrices */
 332:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn;
 517              	 .loc 1 332 0
 518 032c 7B6E     	 ldr r3,[r7,#100]
 519 032e 3B66     	 str r3,[r7,#96]
 333:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT2 = pOut;
 520              	 .loc 1 333 0
 521 0330 3B6A     	 ldr r3,[r7,#32]
 522 0332 FB65     	 str r3,[r7,#92]
 334:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 335:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* index used to check for pivot element */
 336:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       i = 0u;
 523              	 .loc 1 336 0
 524 0334 0023     	 movs r3,#0
 525 0336 3B64     	 str r3,[r7,#64]
 337:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 338:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of rows */
 339:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /*  to be replaced by the sum of that row and a multiple of row i */
 340:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       k = numRows;
 526              	 .loc 1 340 0
 527 0338 FB69     	 ldr r3,[r7,#28]
 528 033a FB62     	 str r3,[r7,#44]
 341:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 342:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while (k > 0u)
 529              	 .loc 1 342 0
 530 033c 60E0     	 b .L44
 531              	.L51:
 343:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 344:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Check for the pivot element */
 345:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         if (i == l)
 532              	 .loc 1 345 0
 533 033e 3A6C     	 ldr r2,[r7,#64]
 534 0340 BB6A     	 ldr r3,[r7,#40]
 535 0342 9A42     	 cmp r2,r3
 536 0344 0CD1     	 bne .L45
 346:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 347:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* If the processing element is the pivot element,
 348:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              only the columns to the right are to be processed */
 349:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT1 += numCols - l;
 537              	 .loc 1 349 0
 538 0346 BA69     	 ldr r2,[r7,#24]
 539 0348 BB6A     	 ldr r3,[r7,#40]
 540 034a D31A     	 subs r3,r2,r3
 541 034c 9B00     	 lsls r3,r3,#2
 542 034e 3A6E     	 ldr r2,[r7,#96]
 543 0350 1344     	 add r3,r3,r2
 544 0352 3B66     	 str r3,[r7,#96]
 350:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 351:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT2 += numCols;
 545              	 .loc 1 351 0
 546 0354 BB69     	 ldr r3,[r7,#24]
 547 0356 9B00     	 lsls r3,r3,#2
 548 0358 FA6D     	 ldr r2,[r7,#92]
 549 035a 1344     	 add r3,r3,r2
 550 035c FB65     	 str r3,[r7,#92]
 551 035e 44E0     	 b .L46
 552              	.L45:
 352:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 353:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         else
 354:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 355:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Element of the reference row */
 356:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           in = *pInT1;
 553              	 .loc 1 356 0
 554 0360 3B6E     	 ldr r3,[r7,#96]
 555 0362 1B68     	 ldr r3,[r3]
 556 0364 7B64     	 str r3,[r7,#68]
 357:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 358:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Working pointers for input and destination pivot rows */
 359:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_in = pPivotRowIn;
 557              	 .loc 1 359 0
 558 0366 3B69     	 ldr r3,[r7,#16]
 559 0368 3B65     	 str r3,[r7,#80]
 360:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_pDst = pPivotRowDst;
 560              	 .loc 1 360 0
 561 036a FB68     	 ldr r3,[r7,#12]
 562 036c FB64     	 str r3,[r7,#76]
 361:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 362:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to the right of the pivot element,
 363:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              to replace the elements in the input matrix */
 364:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           j = (numCols - l);
 563              	 .loc 1 364 0
 564 036e BA69     	 ldr r2,[r7,#24]
 565 0370 BB6A     	 ldr r3,[r7,#40]
 566 0372 D31A     	 subs r3,r2,r3
 567 0374 7B63     	 str r3,[r7,#52]
 365:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 366:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           while (j > 0u)
 568              	 .loc 1 366 0
 569 0376 17E0     	 b .L47
 570              	.L48:
 367:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 368:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row
 369:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
 370:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             in1 = *pInT1;
 571              	 .loc 1 370 0
 572 0378 3B6E     	 ldr r3,[r7,#96]
 573 037a 1B68     	 ldr r3,[r3]
 574 037c BB60     	 str r3,[r7,#8]
 371:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             *pInT1++ = in1 - (in * *pPRT_in++);
 575              	 .loc 1 371 0
 576 037e 3B6E     	 ldr r3,[r7,#96]
 577 0380 1A1D     	 adds r2,r3,#4
 578 0382 3A66     	 str r2,[r7,#96]
 579 0384 3A6D     	 ldr r2,[r7,#80]
 580 0386 111D     	 adds r1,r2,#4
 581 0388 3965     	 str r1,[r7,#80]
 582 038a 92ED007A 	 flds s14,[r2]
 583 038e D7ED117A 	 flds s15,[r7,#68]
 584 0392 67EE277A 	 fmuls s15,s14,s15
 585 0396 97ED027A 	 flds s14,[r7,#8]
 586 039a 77EE677A 	 fsubs s15,s14,s15
 587 039e C3ED007A 	 fsts s15,[r3]
 372:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 373:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Decrement the loop counter */
 374:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             j--;
 588              	 .loc 1 374 0
 589 03a2 7B6B     	 ldr r3,[r7,#52]
 590 03a4 013B     	 subs r3,r3,#1
 591 03a6 7B63     	 str r3,[r7,#52]
 592              	.L47:
 366:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 593              	 .loc 1 366 0
 594 03a8 7B6B     	 ldr r3,[r7,#52]
 595 03aa 002B     	 cmp r3,#0
 596 03ac E4D1     	 bne .L48
 375:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 376:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 377:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to
 378:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              replace the elements in the destination matrix */
 379:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           j = numCols;
 597              	 .loc 1 379 0
 598 03ae BB69     	 ldr r3,[r7,#24]
 599 03b0 7B63     	 str r3,[r7,#52]
 380:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 381:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           while (j > 0u)
 600              	 .loc 1 381 0
 601 03b2 17E0     	 b .L49
 602              	.L50:
 382:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 383:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row
 384:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
 385:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             in1 = *pInT2;
 603              	 .loc 1 385 0
 604 03b4 FB6D     	 ldr r3,[r7,#92]
 605 03b6 1B68     	 ldr r3,[r3]
 606 03b8 BB60     	 str r3,[r7,#8]
 386:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             *pInT2++ = in1 - (in * *pPRT_pDst++);
 607              	 .loc 1 386 0
 608 03ba FB6D     	 ldr r3,[r7,#92]
 609 03bc 1A1D     	 adds r2,r3,#4
 610 03be FA65     	 str r2,[r7,#92]
 611 03c0 FA6C     	 ldr r2,[r7,#76]
 612 03c2 111D     	 adds r1,r2,#4
 613 03c4 F964     	 str r1,[r7,#76]
 614 03c6 92ED007A 	 flds s14,[r2]
 615 03ca D7ED117A 	 flds s15,[r7,#68]
 616 03ce 67EE277A 	 fmuls s15,s14,s15
 617 03d2 97ED027A 	 flds s14,[r7,#8]
 618 03d6 77EE677A 	 fsubs s15,s14,s15
 619 03da C3ED007A 	 fsts s15,[r3]
 387:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 388:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Decrement the loop counter */
 389:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             j--;
 620              	 .loc 1 389 0
 621 03de 7B6B     	 ldr r3,[r7,#52]
 622 03e0 013B     	 subs r3,r3,#1
 623 03e2 7B63     	 str r3,[r7,#52]
 624              	.L49:
 381:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 625              	 .loc 1 381 0
 626 03e4 7B6B     	 ldr r3,[r7,#52]
 627 03e6 002B     	 cmp r3,#0
 628 03e8 E4D1     	 bne .L50
 629              	.L46:
 390:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 391:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 392:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 393:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 394:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Increment the temporary input pointer */
 395:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1 = pInT1 + l;
 630              	 .loc 1 395 0
 631 03ea BB6A     	 ldr r3,[r7,#40]
 632 03ec 9B00     	 lsls r3,r3,#2
 633 03ee 3A6E     	 ldr r2,[r7,#96]
 634 03f0 1344     	 add r3,r3,r2
 635 03f2 3B66     	 str r3,[r7,#96]
 396:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 397:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement the loop counter */
 398:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         k--;
 636              	 .loc 1 398 0
 637 03f4 FB6A     	 ldr r3,[r7,#44]
 638 03f6 013B     	 subs r3,r3,#1
 639 03f8 FB62     	 str r3,[r7,#44]
 399:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 400:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Increment the pivot index */
 401:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         i++;
 640              	 .loc 1 401 0
 641 03fa 3B6C     	 ldr r3,[r7,#64]
 642 03fc 0133     	 adds r3,r3,#1
 643 03fe 3B64     	 str r3,[r7,#64]
 644              	.L44:
 342:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 645              	 .loc 1 342 0
 646 0400 FB6A     	 ldr r3,[r7,#44]
 647 0402 002B     	 cmp r3,#0
 648 0404 9BD1     	 bne .L51
 402:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 403:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 404:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the input pointer */
 405:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pIn++;
 649              	 .loc 1 405 0
 650 0406 7B6E     	 ldr r3,[r7,#100]
 651 0408 0433     	 adds r3,r3,#4
 652 040a 7B66     	 str r3,[r7,#100]
 406:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 407:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement the loop counter */
 408:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       loopCnt--;
 653              	 .loc 1 408 0
 654 040c 3B6B     	 ldr r3,[r7,#48]
 655 040e 013B     	 subs r3,r3,#1
 656 0410 3B63     	 str r3,[r7,#48]
 409:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 410:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the index modifier */
 411:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       l++;
 657              	 .loc 1 411 0
 658 0412 BB6A     	 ldr r3,[r7,#40]
 659 0414 0133     	 adds r3,r3,#1
 660 0416 BB62     	 str r3,[r7,#40]
 661              	.L11:
 184:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 662              	 .loc 1 184 0
 663 0418 3B6B     	 ldr r3,[r7,#48]
 664 041a 002B     	 cmp r3,#0
 665 041c 7FF453AE 	 bne .L52
 412:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 413:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 414:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 415:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #else
 416:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 417:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Run the below code for Cortex-M0 */
 418:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 419:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t Xchg, in = 0.0f;                     /* Temporary input values  */
 420:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t i, rowCnt, flag = 0u, j, loopCnt, k, l;      /* loop counters */
 421:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   arm_status status;                             /* status of matrix inverse */
 422:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 423:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #ifdef ARM_MATH_MATRIX_CHECK
 424:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 425:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Check for matrix mismatch condition */
 426:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   if ((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
 427:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****      || (pSrc->numRows != pDst->numRows))
 428:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   {
 429:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Set status as ARM_MATH_SIZE_MISMATCH */
 430:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     status = ARM_MATH_SIZE_MISMATCH;
 431:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   }
 432:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   else
 433:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
 434:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   {
 435:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 436:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /*---------------------------------------------------------------------------------------------
 437:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 * Matrix Inverse can be solved using elementary row operations.
 438:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 439:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	Gauss-Jordan Method:
 440:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 441:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an
 442:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *        augmented matrix as follows:
 443:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *				        _  _	      _	    _	   _   _         _	       _
 444:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |  |  a11  a12  | | | 1   0  |   |       |  X11 X12  |
 445:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |  |            | | |        |   |   =   |           |
 446:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |_ |_ a21  a22 _| | |_0   1 _|  _|       |_ X21 X21 _|
 447:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 448:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		2. In our implementation, pDst Matrix is used as identity matrix.
 449:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 450:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		3. Begin with the first row. Let i = 1.
 451:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 452:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    4. Check to see if the pivot for row i is zero.
 453:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   The pivot is the element of the main diagonal that is on the current row.
 454:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   For instance, if working with row i, then the pivot element is aii.
 455:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   If the pivot is zero, exchange that row with a row below it that does not
 456:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   contain a zero in column i. If this is not possible, then an inverse
 457:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   to that matrix does not exist.
 458:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 459:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    5. Divide every element of row i by the pivot.
 460:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 461:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    6. For every row below and  row i, replace that row with the sum of that row and
 462:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   a multiple of row i so that each new element in column i below row i is zero.
 463:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 464:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros
 465:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   for every element below and above the main diagonal.
 466:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 467:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, src).
 468:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   Therefore, the matrix to the right of the bar is our solution(dst matrix, dst).
 469:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *------------------------------------------------------------------------------------------------
 470:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 471:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Working pointer for destination matrix */
 472:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     pOutT1 = pOut;
 473:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 474:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of rows */
 475:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     rowCnt = numRows;
 476:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 477:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Making the destination matrix as identity matrix */
 478:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     while (rowCnt > 0u)
 479:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 480:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in lower triangle of the destination matrix */
 481:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = numRows - rowCnt;
 482:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0u)
 483:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 484:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
 485:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 486:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 487:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 488:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all ones in the diagonal of the destination matrix */
 489:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       *pOutT1++ = 1.0f;
 490:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 491:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in upper triangle of the destination matrix */
 492:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = rowCnt - 1u;
 493:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0u)
 494:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 495:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
 496:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 497:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 498:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 499:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement the loop counter */
 500:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       rowCnt--;
 501:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 502:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 503:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of columns of the input matrix.
 504:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        All the elements in each column are processed by the row operations */
 505:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     loopCnt = numCols;
 506:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 507:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Index modifier to navigate through the columns */
 508:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     l = 0u;
 509:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     //for(loopCnt = 0u; loopCnt < numCols; loopCnt++)
 510:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     while (loopCnt > 0u)
 511:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 512:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is zero..
 513:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * If it is zero then interchange the row with non zero row below.
 514:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * If there is no non zero element to replace in the rows below,
 515:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * then the matrix is Singular. */
 516:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 517:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the input matrix that points
 518:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
 519:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn + (l * numCols);
 520:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 521:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the destination matrix that points
 522:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
 523:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pOut + (l * numCols);
 524:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 525:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary variable to hold the pivot value */
 526:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *pInT1;
 527:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 528:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Destination pointer modifier */
 529:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       k = 1u;
 530:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 531:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is zero */
 532:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if (*pInT1 == 0.0f)
 533:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 534:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Loop over the number rows present below */
 535:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         for (i = (l + 1u); i < numRows; i++)
 536:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 537:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the input and destination pointers */
 538:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT2 = pInT1 + (numCols * l);
 539:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pOutT2 = pOutT1 + (numCols * k);
 540:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 541:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Check if there is a non zero pivot element to
 542:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****            * replace in the rows below */
 543:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           if (*pInT2 != 0.0f)
 544:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 545:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Loop over number of columns
 546:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              * to the right of the pilot element */
 547:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             for (j = 0u; j < (numCols - l); j++)
 548:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 549:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Exchange the row elements of the input matrix */
 550:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pInT2;
 551:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT2++ = *pInT1;
 552:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT1++ = Xchg;
 553:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 554:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 555:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             for (j = 0u; j < numCols; j++)
 556:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 557:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pOutT2;
 558:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT2++ = *pOutT1;
 559:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT1++ = Xchg;
 560:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 561:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 562:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Flag to indicate whether exchange is done or not */
 563:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             flag = 1u;
 564:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 565:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Break after exchange is done */
 566:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             break;
 567:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 568:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 569:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the destination pointer modifier */
 570:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           k++;
 571:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 572:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 573:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 574:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Update the status if the matrix is singular */
 575:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if ((flag != 1u) && (in == 0.0f))
 576:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 577:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         return ARM_MATH_SINGULAR;
 578:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 579:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 580:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Points to the pivot row of input and destination matrices */
 581:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowIn = pIn + (l * numCols);
 582:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowDst = pOut + (l * numCols);
 583:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 584:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers to the pivot row pointers */
 585:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pPivotRowIn;
 586:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pPivotRowDst;
 587:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 588:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Pivot element of the row */
 589:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *(pIn + (l * numCols));
 590:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 591:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of columns
 592:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the right of the pilot element */
 593:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (j = 0u; j < (numCols - l); j++)
 594:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 595:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the input matrix
 596:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
 597:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pInT1 = *pInT1 / in;
 598:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1++;
 599:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 600:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (j = 0u; j < numCols; j++)
 601:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 602:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the destination matrix
 603:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
 604:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1 = *pOutT1 / in;
 605:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pOutT1++;
 606:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 607:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 608:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Replace the rows with the sum of that row and a multiple of row i
 609:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * so that each new element in column i above row i is zero.*/
 610:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 611:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers for input and destination matrices */
 612:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn;
 613:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pOut;
 614:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 615:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = 0u; i < numRows; i++)
 616:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 617:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Check for the pivot element */
 618:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         if (i == l)
 619:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 620:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* If the processing element is the pivot element,
 621:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              only the columns to the right are to be processed */
 622:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT1 += numCols - l;
 623:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pOutT1 += numCols;
 624:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 625:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         else
 626:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 627:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Element of the reference row */
 628:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           in = *pInT1;
 629:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 630:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Working pointers for input and destination pivot rows */
 631:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_in = pPivotRowIn;
 632:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_pDst = pPivotRowDst;
 633:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 634:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to the right of the pivot element,
 635:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              to replace the elements in the input matrix */
 636:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           for (j = 0u; j < (numCols - l); j++)
 637:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 638:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row
 639:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
 640:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             *pInT1 = *pInT1 - (in * *pPRT_in++);
 641:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             pInT1++;
 642:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 643:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to
 644:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              replace the elements in the destination matrix */
 645:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           for (j = 0u; j < numCols; j++)
 646:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 647:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row
 648:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
 649:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             *pOutT1 = *pOutT1 - (in * *pPRT_pDst++);
 650:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             pOutT1++;
 651:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 652:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 653:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 654:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Increment the temporary input pointer */
 655:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1 = pInT1 + l;
 656:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 657:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the input pointer */
 658:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pIn++;
 659:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 660:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement the loop counter */
 661:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       loopCnt--;
 662:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the index modifier */
 663:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       l++;
 664:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 665:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 666:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 667:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #endif /* #if defined (ARM_MATH_DSP) */
 668:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 669:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Set status as ARM_MATH_SUCCESS */
 670:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     status = ARM_MATH_SUCCESS;
 666              	 .loc 1 670 0
 667 0420 0023     	 movs r3,#0
 668 0422 87F82730 	 strb r3,[r7,#39]
 671:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 672:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     if ((flag != 1u) && (in == 0.0f))
 669              	 .loc 1 672 0
 670 0426 BB6B     	 ldr r3,[r7,#56]
 671 0428 012B     	 cmp r3,#1
 672 042a 2CD0     	 beq .L4
 673              	 .loc 1 672 0 is_stmt 0 discriminator 1
 674 042c D7ED117A 	 flds s15,[r7,#68]
 675 0430 F5EE407A 	 fcmpzs s15
 676 0434 F1EE10FA 	 fmstat
 677 0438 25D1     	 bne .L4
 673:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 674:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pIn = pSrc->pData;
 678              	 .loc 1 674 0 is_stmt 1
 679 043a 7B68     	 ldr r3,[r7,#4]
 680 043c 5B68     	 ldr r3,[r3,#4]
 681 043e 7B66     	 str r3,[r7,#100]
 675:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = 0; i < numRows * numCols; i++)
 682              	 .loc 1 675 0
 683 0440 0023     	 movs r3,#0
 684 0442 3B64     	 str r3,[r7,#64]
 685 0444 0EE0     	 b .L53
 686              	.L56:
 676:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 677:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         if (pIn[i] != 0.0f)
 687              	 .loc 1 677 0
 688 0446 3B6C     	 ldr r3,[r7,#64]
 689 0448 9B00     	 lsls r3,r3,#2
 690 044a 7A6E     	 ldr r2,[r7,#100]
 691 044c 1344     	 add r3,r3,r2
 692 044e D3ED007A 	 flds s15,[r3]
 693 0452 F5EE407A 	 fcmpzs s15
 694 0456 F1EE10FA 	 fmstat
 695 045a 00D0     	 beq .L54
 678:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             break;
 696              	 .loc 1 678 0
 697 045c 09E0     	 b .L55
 698              	.L54:
 675:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = 0; i < numRows * numCols; i++)
 699              	 .loc 1 675 0 discriminator 2
 700 045e 3B6C     	 ldr r3,[r7,#64]
 701 0460 0133     	 adds r3,r3,#1
 702 0462 3B64     	 str r3,[r7,#64]
 703              	.L53:
 675:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = 0; i < numRows * numCols; i++)
 704              	 .loc 1 675 0 is_stmt 0 discriminator 1
 705 0464 FB69     	 ldr r3,[r7,#28]
 706 0466 BA69     	 ldr r2,[r7,#24]
 707 0468 02FB03F2 	 mul r2,r2,r3
 708 046c 3B6C     	 ldr r3,[r7,#64]
 709 046e 9A42     	 cmp r2,r3
 710 0470 E9D8     	 bhi .L56
 711              	.L55:
 679:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 680:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 681:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if (i == numRows * numCols)
 712              	 .loc 1 681 0 is_stmt 1
 713 0472 FB69     	 ldr r3,[r7,#28]
 714 0474 BA69     	 ldr r2,[r7,#24]
 715 0476 02FB03F2 	 mul r2,r2,r3
 716 047a 3B6C     	 ldr r3,[r7,#64]
 717 047c 9A42     	 cmp r2,r3
 718 047e 02D1     	 bne .L4
 682:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         status = ARM_MATH_SINGULAR;
 719              	 .loc 1 682 0
 720 0480 FB23     	 movs r3,#251
 721 0482 87F82730 	 strb r3,[r7,#39]
 722              	.L4:
 683:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 684:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   }
 685:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Return to application */
 686:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   return (status);
 723              	 .loc 1 686 0
 724 0486 97F82730 	 ldrb r3,[r7,#39]
 725              	.L24:
 726 048a 5BB2     	 sxtb r3,r3
 687:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** }
 727              	 .loc 1 687 0
 728 048c 1846     	 mov r0,r3
 729 048e 6C37     	 adds r7,r7,#108
 730              	.LCFI3:
 731              	 .cfi_def_cfa_offset 4
 732 0490 BD46     	 mov sp,r7
 733              	.LCFI4:
 734              	 .cfi_def_cfa_register 13
 735              	 
 736 0492 5DF8047B 	 ldr r7,[sp],#4
 737              	.LCFI5:
 738              	 .cfi_restore 7
 739              	 .cfi_def_cfa_offset 0
 740 0496 7047     	 bx lr
 741              	 .cfi_endproc
 742              	.LFE135:
 744              	 .text
 745              	.Letext0:
 746              	 .file 2 "c:\\program files (x86)\\dave\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 747              	 .file 3 "c:\\program files (x86)\\dave\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 748              	 .file 4 "F:/Projects/20190909 - 3phase_inverter/3phase_inverter/4. Software_WS/OL_VSC_vitor/Dave/Generated/CMSIS_DSP/arm_math.h"
DEFINED SYMBOLS
                            *ABS*:00000000 arm_mat_inverse_f32.c
    {standard input}:20     .text.arm_mat_inverse_f32:00000000 $t
    {standard input}:25     .text.arm_mat_inverse_f32:00000000 arm_mat_inverse_f32
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
